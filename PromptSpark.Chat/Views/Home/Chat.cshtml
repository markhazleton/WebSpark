@{
}


<div class="container py-5">
    <div class="card shadow-sm">
        <header class="card-header bg-primary text-white text-center">
            <h2 class="mb-0">PromptSpark Chat</h2>
        </header>
        <div class="card-body">
            <div id="userForm" class="mb-4">
                <label for="userInput" class="form-label">Enter your name to join the chat:</label>
                <input type="text" id="userInput" class="form-control" placeholder="Your name" aria-label="User name input" />
                <button class="btn btn-primary mt-2" onclick="joinChat()">Join Chat</button>
            </div>
            <div id="chatWindow" style="display: none;">
                <div id="connectionStatus" class="text-muted mb-2">Connecting...</div>
                <ul id="messagesList" class="list-unstyled mb-3 p-3 border rounded bg-light overflow-auto" style="height: 300px; max-height: 400px;" aria-live="polite">
                </ul>
                <div id="optionsContainer" class="d-flex flex-wrap gap-2 mb-3" style="display: none;"></div>
                <div class="input-group" id="inputMessage">
                    <input type="text" id="messageInput" class="form-control" placeholder="Type your message here..." aria-label="Message input" />
                    <button class="btn btn-primary" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>
</div>

@section HeadScripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.9/signalr.min.js" defer></script>
    <script src="https://unpkg.com/adaptivecards@2.11.0/dist/adaptivecards.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.12/marked.min.js" defer></script>
}

@section Scripts {
    <script>
        let connection;
        let userName = "";
        let conversationId = localStorage.getItem("conversationId") || generateConversationId();
        let inWorkflow = JSON.parse(localStorage.getItem("inWorkflow")) || false;
        let retryCount = 0;
        let currentMessageContainer = null;
        let lastMessageUser = null;
        let activeMessageId = null;


        function generateConversationId() {
            return Math.random().toString(36).substring(2, 15);
        }

        async function start() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub")
                .configureLogging(signalR.LogLevel.Information)
                .build();

            try {
                await connection.start();
                console.log("Connected to SignalR hub!");
                retryCount = 0;
                document.getElementById("connectionStatus").style.display = "none";
                connection.on("ReceiveAdaptiveCard", handleReceiveAdaptiveCard);
                connection.on("ReceiveMessage", handleReceiveMessage);

            } catch (err) {
                retryCount++;
                console.error("Connection failed: ", err);
                document.getElementById("connectionStatus").textContent = "Reconnecting...";
                if (retryCount < 5) {
                    setTimeout(start, Math.min(5000 * retryCount, 30000)); // Exponential backoff
                } else {
                    document.getElementById("connectionStatus").textContent = "Unable to connect. Please try again later.";
                }
            }
        }

        function handleReceiveAdaptiveCard(adaptiveCardJson) {
            const messagesList = document.getElementById("messagesList");

            // Initialize the AdaptiveCard instance
            const adaptiveCard = new AdaptiveCards.AdaptiveCard();
            adaptiveCard.parse(JSON.parse(adaptiveCardJson));
            const renderedCard = adaptiveCard.render();

            const cardContainer = document.createElement("li");
            cardContainer.classList.add("mb-3", "p-3", "bg-white", "shadow-sm", "rounded");
            cardContainer.appendChild(renderedCard);
            messagesList.appendChild(cardContainer);
            messagesList.scrollTop = messagesList.scrollHeight;

            // Set up the onExecuteAction to disable buttons on click
            adaptiveCard.onExecuteAction = async function (action) {
                if (action.data && action.data.option) {
                    await progressWorkflow(action.data.option);
                    // Disable all buttons and selects within the rendered card
                    renderedCard.querySelectorAll("button, select").forEach(element => element.disabled = true);

                    // Add visual indication that the card is disabled
                    renderedCard.style.opacity = "0.5";
                    renderedCard.style.pointerEvents = "none";
                }
            };
        }


        function handleReceiveMessage(user, messageChunk, messageId) {
            const messagesList = document.getElementById("messagesList");

            console.log(`Received message chunk from ${user}: "${messageChunk}", message ID: ${messageId}`);

            // Check if we need to start a new container based on a new message ID or sender
            if (!currentMessageContainer || lastMessageUser !== user || activeMessageId !== messageId) {
                console.log("Creating a new message container for:", user);

                // Create a new message container for the new message
                currentMessageContainer = document.createElement("div");
                currentMessageContainer.classList.add("mb-2", "p-3", "rounded");

                // Apply different styles based on sender
                if (user === "PromptSpark") {
                    currentMessageContainer.classList.add("bg-primary", "text-white");
                } else {
                    currentMessageContainer.classList.add("bg-light", "text-dark");
                }

                // Only add the sender label once
                currentMessageContainer.innerHTML = `<strong>${user}:</strong> <span class="message-content"></span>`;
                messagesList.appendChild(currentMessageContainer);
                lastMessageUser = user;
                activeMessageId = messageId; // Set the active message ID
            } else {
                console.log("Appending to the existing message container for:", user);
            }

            // Append the current message chunk to the message content
            const messageContentSpan = currentMessageContainer.querySelector(".message-content");
            const formattedChunk = typeof marked !== "undefined" ? marked.parseInline(messageChunk) : messageChunk;
            messageContentSpan.innerHTML += formattedChunk;

            // Scroll to the latest message to maintain streaming effect
            messagesList.scrollTop = messagesList.scrollHeight;

            // If the chunk is empty, it likely indicates the end of the message
            if (messageChunk === "") {
                console.log("Final chunk received, resetting container for next message.");
                currentMessageContainer = null;
                lastMessageUser = null;
                activeMessageId = null;
            }

            // Debugging: log the current state of the container after each update
            console.log("Current message container content:", currentMessageContainer ? currentMessageContainer.innerHTML : "No active container");
        }

        async function joinChat() {
            userName = document.getElementById("userInput").value.trim();
            if (userName && userName.length <= 50) { // Basic validation
                document.getElementById("userForm").style.display = "none";
                document.getElementById("chatWindow").style.display = "block";
                document.getElementById("messageInput").focus();
                await connection.invoke("SetUserName", conversationId, userName);
                startWorkflow();
            } else {
                alert("Please enter a valid name (max 50 characters).");
            }
        }

        async function startWorkflow() {
            try {
                await connection.invoke("ProgressWorkflow", conversationId,"");
                inWorkflow = true;
                localStorage.setItem("inWorkflow", JSON.stringify(inWorkflow));
            } catch (err) {
                console.error("Workflow initiation failed: ", err);
            }
        }

        async function sendMessage() {
            const message = document.getElementById("messageInput").value.trim();
            if (userName && message) {
                try {
                    if (inWorkflow) {
                        await progressWorkflow(message);
                    } else {
                        await connection.invoke("SendMessage", userName, message, conversationId);
                    }
                    document.getElementById("messageInput").value = '';
                } catch (err) {
                    console.error("SendMessage failed: ", err);
                }
            }
        }

        async function progressWorkflow(response) {
            try {
                await connection.invoke("ProgressWorkflow", conversationId, response);
            } catch (err) {
                console.error("ProgressWorkflow failed: ", err);
            }
        }

        document.addEventListener("DOMContentLoaded", function () {
            start();
        });

        document.getElementById("messageInput").addEventListener("keypress", function (event) {
            if (event.key === "Enter") {
                event.preventDefault();
                sendMessage();
            }
        });
    </script>
}
