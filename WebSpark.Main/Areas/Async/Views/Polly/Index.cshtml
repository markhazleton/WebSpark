@using HttpClientUtility.MockService
@model MockResults
@{
    ViewData["Title"] = "Async API Polly Page - Resilient API Calls with Polly in .NET 8";
    var bgColorClass = Model?.ResultValue == "-1" ? "bg-danger" : "bg-success"; // Using Bootstrap background color classes
}

<div class="container-fluid my-5">
    <div class="row mb-4">
        <div class="col-md-12 text-center">
            <h1 class="display-4">
                <i class="bi bi-arrow-repeat"></i> Polly Async API Demo
            </h1>
            <p class="lead">
                Learn how to build resilient .NET 8 web applications using Polly for advanced retry strategies. Explore the power of asynchronous programming to handle transient faults in HTTP requests efficiently.
            </p>
        </div>
    </div>

    <div class="row">
        <div class="col-md-4">
            <!-- Apply Bootstrap classes for styling -->
            <dl class="@bgColorClass text-white rounded p-3">
                <dt class="text-start ps-2"><i class="bi bi-loop"></i> Loop Count</dt>
                <dd class="text-start ps-2 border-bottom">@Model?.LoopCount</dd>
                <dt class="text-start ps-2"><i class="bi bi-clock-history"></i> Max Time (ms)</dt>
                <dd class="text-start ps-2 border-bottom">@Model?.MaxTimeMS</dd>
                <dt class="text-start ps-2"><i class="bi bi-check-circle-fill"></i> Result</dt>
                <dd class="text-start ps-2 border-bottom">@Model?.ResultValue</dd>
                <dt class="text-start ps-2"><i class="bi bi-speedometer2"></i> RunTime (ms)</dt>
                <dd class="text-start ps-2 border-bottom">@Model?.RunTimeMS</dd>
                <dt class="text-start ps-2"><i class="bi bi-info-circle"></i> Message</dt>
                <dd class="text-start ps-2">@Html.Raw(Model?.Message)</dd>
            </dl>
            <div class="text-center">
                <div class="test-list">
                    <h2 class="h5 mb-3"><i class="bi bi-play-circle"></i> Test the API with Polly Timeouts</h2>
                    <nav class="nav flex-column nav-pills p-2 border rounded">
                        <a class="nav-link border-bottom py-2" href="/async/polly?loopCount=40&maxTimeMs=1500">40 Loops, max 1.5 seconds</a>
                        <a class="nav-link border-bottom py-2" href="/async/polly?loopCount=40&maxTimeMs=1000">40 Loops, max 1 second</a>
                        <a class="nav-link py-2" href="/async/polly?loopCount=40&maxTimeMs=500">40 Loops, max 1/2 second</a>
                    </nav>
                </div>
            </div>
        </div>
        <div class="col-md-8">
            <div>
                <form class="form-horizontal" action="/async/polly" method="get">
                    <fieldset>
                        <legend><i class="bi bi-gear"></i> Submit Timeout Test</legend>
                        <p>
                            This demonstration showcases how to handle transient errors in HTTP requests using Polly's async retry strategies. Select the number of loops and the maximum allowed response time to see Polly in action.
                        </p>
                        <div class="form-group row">
                            <label class="col-md-4 control-label" for="loopCount">Number of Loops</label>
                            <div class="col-md-8">
                                <select id="loopCount" name="loopCount" class="form-control">
                                    @for (int i = 10; i <= 100; i += 10)
                                    {
                                        if (Model?.LoopCount == i)
                                        {
                                            <option value="@i" selected>@i</option>
                                        }
                                        else
                                        {
                                            <option value="@i">@i</option>
                                        }
                                    }
                                </select>
                            </div>
                        </div>
                        <div class="form-group row mt-3">
                            <label class="col-md-4 control-label" for="maxTimeMs">Max Response Time</label>
                            <div class="col-md-8">
                                <select id="maxTimeMs" name="maxTimeMs" class="form-control">
                                    @foreach (var time in new[] { 100, 200, 500, 750, 1000, 1500, 3000, 5000 })
                                    {
                                        if (Model?.MaxTimeMS == time)
                                        {
                                            <option value="@time" selected>@time</option>
                                        }
                                        else
                                        {
                                            <option value="@time">@time</option>
                                        }
                                    }
                                </select>
                            </div>
                        </div>
                        <div class="form-group row mt-3">
                            <label class="col-md-4 control-label" for="singlebutton">Submit Request</label>
                            <div class="col-md-8">
                                <button id="singlebutton" name="singlebutton" class="btn btn-primary">
                                    <i class="bi bi-send"></i> Submit Request
                                </button>
                            </div>
                        </div>
                    </fieldset>
                </form>
            </div>
        </div>
    </div>
</div>


<div class="container-fluid mt-5">
    <div class="row">
        <div class="col-md-12">
            <h2 class="display-5 text-center mb-4"><i class="bi bi-book-fill text-primary"></i> Understanding Polly: History, Purpose, and Best Practices</h2>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <h3><i class="bi bi-clock-history"></i> History and Purpose of Polly</h3>
            <p>
                Polly is a .NET resilience and transient-fault-handling library that originated as an open-source project to address the growing need for robust fault-handling in modern, distributed applications. Initially released in 2012, Polly has gained significant traction among developers due to its intuitive syntax and powerful capabilities. Its core purpose is to provide developers with a flexible and reliable way to handle transient faults in network operations, database connections, and other external dependencies.
            </p>
            <p>
                By implementing Polly, developers can apply resilience strategies such as retries, circuit breakers, bulkhead isolation, timeouts, and fallback operations, all using async and synchronous patterns. This approach empowers applications to withstand temporary issues, such as network timeouts or throttling, without crashing or failing outright.
            </p>
        </div>
        <div class="col-md-6">
            <h3><i class="bi bi-people-fill"></i> Public Acceptance and Benefits</h3>
            <p>
                Polly has been widely adopted by the .NET community and is often seen as the de facto standard for resilience handling in .NET applications. It is used by developers and companies of all sizes, including large enterprises and startups, to enhance the stability and reliability of their software solutions. The public's acceptance of Polly stems from its ease of use, extensive documentation, and strong community support, making it an essential tool in the .NET ecosystem.
            </p>
            <p>
                Key benefits of using Polly include improved application reliability, better user experience, and reduced operational costs by minimizing downtime. Polly’s ability to elegantly handle retries with jitter, manage transient errors gracefully, and implement sophisticated resilience patterns has made it a trusted choice for developers aiming to build resilient and robust .NET applications.
            </p>
        </div>
    </div>

    <div class="row mt-4">
        <div class="col-md-6">
            <h3><i class="bi bi-tools"></i> Alternative Approaches to Polly</h3>
            <p>
                While Polly is highly regarded, alternative approaches exist for handling transient faults in .NET applications. Developers can manually implement basic retry logic or use other libraries such as <strong>Resilience4j</strong> (popular in the Java world but adaptable) or native <strong>ASP.NET Core</strong> middleware for resilience patterns. However, these alternatives often lack the flexibility, ease of integration, and community backing that Polly offers.
            </p>
            <p>
                Another approach is leveraging cloud-native solutions like <strong>Azure Application Gateway</strong> or <strong>API Management</strong> which provide built-in retry and circuit-breaking capabilities. While these solutions are effective, they may involve higher costs and can be overkill for simpler scenarios where Polly excels.
            </p>
        </div>
        <div class="col-md-6">
            <h3><i class="bi bi-lightbulb-fill"></i> Best Practices for Using Polly</h3>
            <ul class="list-group">
                <li class="list-group-item"><i class="bi bi-arrow-repeat text-success"></i> <strong>Start with Retries:</strong> Implement basic retry logic with exponential backoff and jitter to handle transient faults.</li>
                <li class="list-group-item"><i class="bi bi-exclamation-triangle text-warning"></i> <strong>Use Circuit Breakers:</strong> Protect downstream systems from overload by breaking the circuit when a threshold of failures is met, allowing time for recovery.</li>
                <li class="list-group-item"><i class="bi bi-diagram-3 text-primary"></i> <strong>Combine Policies:</strong> Leverage multiple Polly policies together, such as combining retries with circuit breakers and fallbacks, to build comprehensive resilience strategies.</li>
                <li class="list-group-item"><i class="bi bi-speedometer2 text-info"></i> <strong>Monitor and Log:</strong> Integrate logging and telemetry to monitor the performance of Polly policies and adjust configurations based on real-world data.</li>
                <li class="list-group-item"><i class="bi bi-sliders text-danger"></i> <strong>Test and Tune:</strong> Regularly test the effectiveness of Polly configurations in staging environments to ensure they handle expected failure scenarios appropriately.</li>
            </ul>
        </div>
    </div>

    <div class="row mt-5">
        <div class="col-md-12 text-center">
            <p class="lead">
                By leveraging Polly, you can significantly enhance the resilience of your .NET applications, making them robust against a wide range of transient failures. Whether you’re building microservices, APIs, or client applications, Polly’s powerful and flexible approach to fault handling ensures that your applications remain reliable and user-friendly under stress.
            </p>
            <a href="https://github.com/App-vNext/Polly" target="_blank" class="btn btn-outline-primary">
                <i class="bi bi-box-arrow-up-right"></i> Learn More About Polly on GitHub
            </a>
        </div>
    </div>
</div>

<!-- SEO Optimized Meta Description -->
@section Scripts {
    <script>
        document.querySelector('meta[name="description"]').setAttribute("content", "Discover the history, purpose, and benefits of Polly in .NET 8. Learn best practices, alternative approaches, and how Polly enhances application resilience through retries, circuit breakers, and more.");
    </script>
}

